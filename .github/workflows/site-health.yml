name: Site health

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Do everything except open/close issues"
        type: boolean
        default: false
  schedule:
    - cron: "17 9 * * *"  # daily 09:17 UTC

# Minimal privileges for this job
permissions:
  contents: read
  issues: write

concurrency:
  group: site-health
  cancel-in-progress: true

env:
  # Pages to audit (space-separated). Include a few critical routes.
  TARGET_URLS: >
    https://garlicrot.github.io/RusherSearch/
    https://garlicrot.github.io/RusherSearch/#/plugins
    https://garlicrot.github.io/RusherSearch/#/themes
    https://garlicrot.github.io/RusherSearch/#/about

  # Category minimums (0‚Äì1)
  PERF_MIN: "0.90"
  ACCESS_MIN: "0.90"
  SEO_MIN: "0.95"
  BP_MIN: "0.90"

  # Linkinator behavior
  LINKINATOR_TIMEOUT_MS: "15000"
  # Skip ANY non-site link + direct release/download assets, mailto, tel
  LINKINATOR_SKIP_1: "^(?!https://garlicrot\\.github\\.io/)"
  LINKINATOR_SKIP_2: "https://github\\.com/.*/releases/download/.*"
  LINKINATOR_SKIP_3: "^mailto:|^tel:"

jobs:
  health:
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4

      - name: üîß Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: üì¶ Install tooling
        run: |
          npm i -g @lhci/cli@0.14.x linkinator@6
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: üèÉ Run Lighthouse on pages
        id: lh
        shell: bash
        run: |
          mkdir -p lhci reports
          i=0
          # Run LHCI for each target URL and collect a tiny summary row
          for URL in ${TARGET_URLS}; do
            i=$((i+1))
            OUTDIR="lhci/run_${i}"
            lhci autorun \
              --collect.url="$URL" \
              --collect.numberOfRuns=1 \
              --upload.target=filesystem \
              --upload.outputDir="$OUTDIR"

            # Find report JSON
            FILE=$(ls -1 "$OUTDIR"/*report.json 2>/dev/null | head -n1 || true)
            if [ -z "$FILE" ]; then FILE=$(ls -1 "$OUTDIR"/*.json | head -n1); fi

            PERF=$(jq -r 'if has("summary") then .summary.categories.performance else .categories.performance.score end' "$FILE")
            ACCESS=$(jq -r 'if has("summary") then .summary.categories.accessibility else .categories.accessibility.score end' "$FILE")
            SEO=$(jq -r 'if has("summary") then .summary.categories.seo else .categories.seo.score end' "$FILE")
            BP=$(jq -r 'if has("summary") then .summary.categories["best-practices"] else .categories["best-practices"].score end' "$FILE")

            jq -n --arg url "$URL" \
                 --arg perf "$PERF" --arg access "$ACCESS" --arg seo "$SEO" --arg bp "$BP" \
                 '{url:$url, performance:($perf|tonumber), accessibility:($access|tonumber), seo:($seo|tonumber), best_practices:($bp|tonumber), report:$ENV.FILE}' \
              > "reports/lh_${i}.json"
          done
          # Merge page summaries into one JSON array
          jq -s '.' reports/lh_*.json > reports/lh_summary.json

          # For step outputs, compute worst (min) per category across pages
          PERF_MIN_PAGE=$(jq '[.[].performance]|min' reports/lh_summary.json)
          ACCESS_MIN_PAGE=$(jq '[.[].accessibility]|min' reports/lh_summary.json)
          SEO_MIN_PAGE=$(jq '[.[].seo]|min' reports/lh_summary.json)
          BP_MIN_PAGE=$(jq '[.[].best_practices]|min' reports/lh_summary.json)
          echo "perf=${PERF_MIN_PAGE}"   >> "$GITHUB_OUTPUT"
          echo "access=${ACCESS_MIN_PAGE}" >> "$GITHUB_OUTPUT"
          echo "seo=${SEO_MIN_PAGE}"     >> "$GITHUB_OUTPUT"
          echo "bp=${BP_MIN_PAGE}"       >> "$GITHUB_OUTPUT"

          {
            echo "### Lighthouse scores (worst per category across pages)"
            echo ""
            echo "| Category | Worst Page Score | Minimum |"
            echo "|---|---:|---:|"
            echo "| Performance | ${PERF_MIN_PAGE} | ${PERF_MIN} |"
            echo "| Accessibility | ${ACCESS_MIN_PAGE} | ${ACCESS_MIN} |"
            echo "| SEO | ${SEO_MIN_PAGE} | ${SEO_MIN} |"
            echo "| Best Practices | ${BP_MIN_PAGE} | ${BP_MIN} |"
            echo ""
            echo "<details><summary>Per-page scores</summary>"
            echo ""
            jq -r '.[] | "| " + .url + " | " + (.performance|tostring) + " | " + (.accessibility|tostring) + " | " + (.seo|tostring) + " | " + (.best_practices|tostring) + " |"' reports/lh_summary.json \
              | sed '1i| Page | Perf | A11y | SEO | Best-Prac |' \
              | sed '2i|---|---:|---:|---:|---:|'
            echo ""
            echo "</details>"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: üîó Link check (same-site only)
        id: links
        shell: bash
        run: |
          # Crawl the home page only (cascades across same-site due to --recurse)
          linkinator "https://garlicrot.github.io/RusherSearch/" \
            --recurse \
            --format json \
            --timeout "${LINKINATOR_TIMEOUT_MS}" \
            --skip "${LINKINATOR_SKIP_1}" \
            --skip "${LINKINATOR_SKIP_2}" \
            --skip "${LINKINATOR_SKIP_3}" \
            > linkinator.json || true

          BROKEN_COUNT=$(jq '[.links[] | select(.state=="BROKEN")] | length' linkinator.json)
          echo "broken=${BROKEN_COUNT}" >> "$GITHUB_OUTPUT"

          jq '[.links[] | select(.state=="BROKEN")]
              | sort_by(.status, .url)
              | .[0:20]
              | map({status, url, parent})' linkinator.json > broken-top.json

          {
            echo ""
            echo "### Link check"
            echo ""
            echo "Broken links: ${BROKEN_COUNT}"
            if [ "$BROKEN_COUNT" -gt 0 ]; then
              echo ""
              echo "Top examples:"
              jq -r '.[] | "- \(.status) ‚Äî \(.url)\n  parent: \(.parent)"' broken-top.json
            fi
          } >> "$GITHUB_STEP_SUMMARY"

      - name: üö¶ Gate (decide if we open/close an issue)
        id: gate
        shell: bash
        run: |
          FAIL=0
          awk -v a="${{ steps.lh.outputs.perf }}"   -v b="${PERF_MIN}"   'BEGIN{exit(a<b)}' || FAIL=1
          awk -v a="${{ steps.lh.outputs.access }}" -v b="${ACCESS_MIN}" 'BEGIN{exit(a<b)}' || FAIL=1
          awk -v a="${{ steps.lh.outputs.seo }}"    -v b="${SEO_MIN}"    'BEGIN{exit(a<b)}' || FAIL=1
          awk -v a="${{ steps.lh.outputs.bp }}"     -v b="${BP_MIN}"     'BEGIN{exit(a<b)}' || FAIL=1
          if [ "${{ steps.links.outputs.broken }}" -gt 0 ]; then FAIL=1; fi
          echo "fail=$FAIL" >> "$GITHUB_OUTPUT"
          echo "dry_run=${{ github.event_name == 'workflow_dispatch' && inputs.dry_run }}" >> "$GITHUB_OUTPUT"

      - name: üìù Open or update health issue
        if: ${{ steps.gate.outputs.fail == '1' && steps.gate.outputs.dry_run != 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${process.env.GITHUB_RUN_ID}`;
            const lhSummary = JSON.parse(fs.readFileSync('reports/lh_summary.json','utf8'));
            const broken = fs.existsSync('broken-top.json') ? JSON.parse(fs.readFileSync('broken-top.json','utf8')) : [];

            // Build per-page table
            const pageTable = [
              '| Page | Perf | A11y | SEO | Best-Prac |',
              '|---|---:|---:|---:|---:|',
              ...lhSummary.map(p => `| ${p.url} | ${p.performance} | ${p.accessibility} | ${p.seo} | ${p.best_practices} |`)
            ].join('\n');

            const brokenList = broken.length
              ? broken.map(b => `- ${b.status} ‚Äî ${b.url}\n  parent: ${b.parent}`).join('\n')
              : '- None';

            const badges = [
              `![Perf](https://img.shields.io/badge/perf-${{ steps.lh.outputs.perf }}-informational)`,
              `![A11y](https://img.shields.io/badge/a11y-${{ steps.lh.outputs.access }}-informational)`,
              `![SEO](https://img.shields.io/badge/seo-${{ steps.lh.outputs.seo }}-informational)`,
              `![Best-Prac](https://img.shields.io/badge/best--practices-${{ steps.lh.outputs.bp }}-informational)`,
              `![Broken](https://img.shields.io/badge/broken_links-${{ steps.links.outputs.broken }}-critical)`
            ].join(' ');

            const body = [
              `${badges}`,
              '',
              '**Status:** ‚ùå Regression detected',
              '',
              '### Thresholds',
              `- Performance: ${process.env.PERF_MIN}`,
              `- Accessibility: ${process.env.ACCESS_MIN}`,
              `- SEO: ${process.env.SEO_MIN}`,
              `- Best Practices: ${process.env.BP_MIN}`,
              '',
              '### Worst category scores (across pages)',
              `- Performance: ${{ steps.lh.outputs.perf }}`,
              `- Accessibility: ${{ steps.lh.outputs.access }}`,
              `- SEO: ${{ steps.lh.outputs.seo }}`,
              `- Best Practices: ${{ steps.lh.outputs.bp }}`,
              '',
              '### Per-page scores',
              pageTable,
              '',
              '### Broken links (top 20)',
              brokenList,
              '',
              `<details><summary>Artifacts</summary>

- Lighthouse raw JSON: attached as \`lhci\`
- Linkinator raw JSON: \`linkinator.json\`
- Summary JSON: \`reports/lh_summary.json\`

</details>`,
              '',
              `**Workflow run:** ${runUrl}`
            ].join('\n');

            // Ensure a single rolling "Site health" issue
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner, repo: context.repo.repo,
              state: 'open', labels: 'health'
            });

            const title = 'Site health regression detected';
            const existing = issues.find(i => i.title === title);

            if (existing) {
              await github.rest.issues.createComment({
                owner: context.repo.owner, repo: context.repo.repo,
                issue_number: existing.number, body
              });
            } else {
              await github.rest.issues.create({
                owner: context.repo.owner, repo: context.repo.repo,
                title, body, labels: ['health']
              });
            }

      - name: ‚úÖ Close health issue on recovery
        if: ${{ steps.gate.outputs.fail == '0' && steps.gate.outputs.dry_run != 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner, repo: context.repo.repo,
              state: 'open', labels: 'health'
            });
            const existing = issues.find(i => i.title === 'Site health regression detected');
            if (existing) {
              await github.rest.issues.createComment({
                owner: context.repo.owner, repo: context.repo.repo,
                issue_number: existing.number,
                body: `**Status:** ‚úÖ All checks passing on ${new Date().toISOString()}.\n\nClosing.`
              });
              await github.rest.issues.update({
                owner: context.repo.owner, repo: context.repo.repo,
                issue_number: existing.number, state: 'closed'
              });
            }

      - name: üìé Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: site-health-reports
          path: |
            lhci
            reports/lh_summary.json
            linkinator.json
            broken-top.json
